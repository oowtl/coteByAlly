import sys
import os

sys.stdin = open(os.path.join(os.path.dirname(__file__), 'input.txt'), encoding='utf-8')
"""
=== input.txt 를 불러오기 위한 코드 ===
"""

"""
스트라이크 : 위치 + 값
볼 : 위치 다름 + 값

123 1 1
356 1 0 
327 2 0
489 0 1

접근법은 첫번째 부터 하나씩 경우의 수를 잡아서 밑에 있는 걸로 내려가는 형식의 풀이일 것으로 예상
시간복잡도가 어떻게 계산될지 모르겠음


123 이면, 1이 스트라이크 이고 2가 볼인 경우로 시작 + 3을 제외 시킨다.
356 이면? 3 제외, 5나 6이 볼에 해당한다. => 5를 가정한 케이스(1,2,5) + 6 가정 케이스(1,2,6)
327 이면?
- 2 스트라이크 인데? (1,2,5) 중에 한 개만 있네? => 가정 틀림
- 2 스트라이크 인데? (1,2,6) 중에 한 개만 있다. => 가정 틀림

123 일 때, 스트라이크 1 + 볼 3 로 다시 시작한다. (2 제외)
356 일 때, 볼이 1개 인 조건과 스트라이크 자리에 볼 3이 있는 것이 충돌하기 때문에 가정이 틀렸다.

123 일 때, 스트라이크 2 + 볼 3 으로 다시 시작한다. (1 제외)
356 일 때, 3이 스트라이크가 된다. (5, 6 제외)

이 풀이는 너무 어렵다...
===


1-9 중에 3개의 숫자를 전부 본다면?
N 번 만큼 순회할 필요가 없다면? => 모든 경우의 수를 고려한다는 것은 뭐지?
이 문제의 풀이를 보니까.. 수열로 만들어서 풀어낸다. 그럼 내가 생각하는 브루트 포스와 다른건가?
아예 다르지는 않은 것 같다. 그런데 나는 어렵게 풀려고 한 것 같은데? 

브루트 포스 라는게 문제에서 발생하는 경우의 수를 보는 것이 아니라, 정답이 될 수 있는 모든 경우의 수를 전부 탐색하는 것인가?
=> 모든 정답이 될 수 있는 경우의 수에서 정답이 되는 조건을 만족하는 것이 정답이다.
=> 소거법?

"""
from itertools import permutations

N = int(input())

score = [input().split() for _ in range(N)]
ans = 0

for cur in permutations(range(1, 10), 3): # 수열로 모든 경우의 수를 고려
    ok = True # 조건을 만족하지 못하는 것 break 용도

    for num, s, b in score: # 수열 한 개당 주어진 숫자 전부 순회
        cur_s = cur_b  = 0

        for i in range(3): # 주어진 숫자를 순회
            # 아래의 두 조건을 만족하는 케이스를 사용하는 이유?
            # cur 이 정답인 경우를 가정하기 때문이다.

            if str(cur[i]) == num[i]: # 스트라이크는 같은 자리이고 같은 숫자일 때
                cur_s += 1
            elif str(cur[i]) in num: # 볼은 값만 속하면 된다. elif 라서 같은 자리 + 같은 값인 스트라이크가 이미 실행된 상태
                cur_b += 1

        if cur_s != int(s) or cur_b != int(b): # 다 검사했는데 스트라이크랑 볼 숫자가 다르면 조건에 맞지 않는 것이다.
            ok = False
            break

    if ok:
        ans += 1

print(ans)





