import sys
import os

sys.stdin = open(os.path.join(os.path.dirname(__file__), 'input.txt'), encoding='utf-8')
"""
=== input.txt 를 불러오기 위한 코드 ===
"""

"""
수열 A가 주어졌을 때, 가장 긴 부분 수열의 길이를 구하는 문제
입력
수열 의 길이 N (1 <= N <= 1000)
수열 A의 원소 (1 <= A 원소 <= 1000) 

풀이
DP 유형인 LIS(Longest Increasing Subsequence) 문제

풀이방법
1. 브루트 포스
시간 복잡도 : O(N!) OR O(2^N) -> O(2^N) 으로 본다.
각 자리의 숫자를 포함할지 말지만 보면 된다.
하지만, 이렇게 따지면 2^1000 이기 때문에 시간초과가 난다.

2. 그리디 접근
그리디한 접근 검증 필요
가장 긴 부분 수열을 만들 때 우선순위 조건이 2가지 존재한다.
1. 최대한 가까운 곳에 있는 숫자를 선택한다.
2. 최대한 작은 차이를 가지는 숫자를 선택한다.
이 두 가지 우선순위 중에 무엇이 더 높은 우선순위를 가지는지는 판단할 수 없다.
=> 그리디한 접근은 우선순위를 확실하게 판단할 수 있어야 적용이 가능하므로 그리디한 접근은 불가능하다.

3. DP 접근
DP 는 DP 테이블을 설계해야 한다.

3-1. n 번쨰 까지 살펴봤을 떄의 전체 LIS의 길이
가정
- dp[N] : n 번쨰 까지 살펴봤을 떄의 전체 LIS의 길이
- dp[N] 에서의 LIS 가 dp[N-1] 의 LIS 를 이용할 수 있는 지를 보면 관계식을 도출할 수 있다고 가정
검증
arr = [10, 9, 10, 12, 9, 10]
dp[5] = 3 이다.
dp[6] 을 구하려면 어떻게 해야할까?
만약에 arr = [10, 9, 10, 12, 9, 13] 이라면? dp[N] 에 있는 LIS 의 길이만으로는 부분 수열을 판단할 수 없다.
=> DP 테이블을 다르게 설계해야 한다.

3-2. n에서 끝나는 LIS 의 길이
가정
- dp[N] : n에서 끝나는 LIS 의 길이
- dp[N] 을 갱신하기 위해서는 어떻게 해야할까?
    - 1 ~ N-1의 모든 경우의 수를 살펴보면 알 수 있다. (1 ~ N-1 까지의 LIS를 구한다.)
- 점화식 : dp[N] = (arr[N] 과 최대값 비교) + max(dp[N-1], dp[N-2], ..., dp[1])
    - 단, arr[N]의 값이 dp[x] 의 최대값보다 커야한다. (아니면 부분 수열이 성립하지 않음)
- dp[n] : n번째 원소에서 끝나고 n번째 원소를 선택했을 때, 최대 길이

풀이 (기본식)
dp[n] 을 갱신하는 과정을 나타낸 것

best = 0 # LIS 길이
for i in range(1, n):
    if arr[n] > arr[i]: # arr[n] 이 커야 부분 수열이 성립할 수 있다. 
        best = max(best, arr[i])) # 각 자리와 관계를 맺는 것이라서 순회하면서 가장 큰 것으로 교체한다. 

dp[n] = best + 1 # best 는 arr[n] 과 이어진 것 중에서 가장 큰 부분수열의 길이이기 때문에 여기에서 +1 을 하면 dp[n] 의 값이 된다.

차이점
n 번째까지 살펴봤을 때 전체 LIS 의 길이 vs n에서 끝나는 LIS 의 길이
1. n 번째까지 살펴봤을 때 전체 LIS 의 길이
- n번째 숫자를 포함하지 않아도 된다.
-> dp[n-1] 으로 dp[n] 을 구할 수가 없다. (어떤 순열인지 몰라서)

2. n에서 끝나는 LIS 의 길이
- 반드시 n이 포함되어야 한다.
-> 점화식을 구할 수 있다. (n이 반드시 포함되기 때문에)
"""