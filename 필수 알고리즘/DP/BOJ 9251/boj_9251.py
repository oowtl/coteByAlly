import sys
import os

sys.stdin = open(os.path.join(os.path.dirname(__file__), 'input.txt'), encoding='utf-8')
"""
=== input.txt 를 불러오기 위한 코드 ===
"""

"""
두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제
문자열 두개가 주어지고 모두 알파벳 대문자로 이루어져있다.
최대 1000글자 (1 <= N <= 1000)
출력 : 두 문자열의 LCS의 길이를 출력한다.
- 문자열 S, 첫번째 문자열 s1, 두번째 문자열 s2

풀이
1. 브루트 포스
부분 수열 = 각 자리당 선택할지 말지 => 2^N
비교하면서 찾아야 함 (2중 loop) => (2^N)^2
불가능

2. 그리디 접근법
선택할 수 있는 우선순위가 있나?
탐색한 지점에서 가까워야 한다.
하지만, 탐색지점으로부터 가까울수록 우선순위가 높은 것은 맞지만 우선순위가 충돌하는 경우가 발생한다.
s1 = "A B C D E"
s2 = "A C B D E"
이 경우에 가장 긴 수열은 ABDE, ACDE 이다. 결과는 같지만 그리디한 접근법을 사용할 떄 우선순위를 가릴 수 없다. 

3. DP 접근법
ACAYKP
CAPCAK

A AC ACA 0 ACAK P

3.1 dp[N] = N 번쨰 원소를 포함한 LIS의 길이
dp(N) = (if LIS 에 N번쨰 원소가 포함 1 else 0) + max(dp[N-1] + ... + dp[1])
현재 max 인 LIS 를 확인할 수 있어야 한다.

LIS 를 구하는 것부터?
best? LIS 의 길이

3.2 dp[N] = N 번째 원소를 포함한 LIS
best = LIS 의 길이
dp(N) = S[N] + 1 ~ N-1 까지의 LIS 중에서 S[N]을 포함할 수 있는 LIS
???? 1 ~ N-1 까지의 LIS 중에서 S[N]을 포함할 수 있는 LIS 이 부분을 어떻게 처리하지..?

"""

"""
해답 풀이
두 문자열 S1, S2
두 문자열 S1, S2 의 길이 N, M

1. 브루트 포스
각 문자열 당 2^N 의 시간 복잡도
모든 부분 수열을 조사해야 하기 때문에 시간복잡도는 O(2^N * 2^M) 이다.

2. 그리디 접근법
그리디 접근법을 통해서 손해를 볼 수 있는 상황읆 생각해보자.
A C A F F F F F B
A P C F F F F F A
이 경우에 그리디한 선택, 가까울 수록 우선순위가 있다고 판단하면 ACA 를 결과로 낸다.
그런데 정답은 ACFFFFF 이다. 그래서 바로바로 확정하면 손해를 보게됨
따라서 우선순위를 정할 수 없어서 불가능

3. DP 접근법
1 <= N, M <= 1000 이라서 2차원 테이블을 떠올릴 수 있다.
dp[N][M] : S1 의 N 번째 문자까지 살펴보고, S2 의 M번째 문자까지 살펴봤을 때의 LCS 길이

dp[N][M] 을 구할 수 있는 방법?
1. S1[N] == S2[M] 인 경우
- 같으면 그걸 마지막으로 한 것이 LCS 이다. 
- 점화식 : dp[N][M] = dp[N-1][M-1] + 1
2. S1[N] != S2[M] 인 경우
- 같지 않으면 S1[N] 와 S2[M]가 매칭이 되어서 나오는 LCS 는 존재하지 않는다. => N, M 보다 이전의 인덱스에 있는 값이 LCS 이다. 
- 점화식 : dp[N][M] = max(dp[N-1][M], dp[N][M-1])
- 배열 2개로 생각해보자

* DP 테이블을 2차원 배열로 구성한 뒤에 해야할 생각은? => DP 테이블을 어떻게 갱신 해야 하지?
DP 접근은 N, M 에서의 dp 값에서 부터 시작.
dp[N][M] 의 값을 만들기 위해서 N-1, M-1 에서 어떻게 해야 하는가?
"""

"""
DP 테이블 설계하기
문제에서 주어진 N, M 의 크기와 구조에 따라서 DP Table 을 설계한다.₩
N, M 이 1000 이하이다.
N * M = 최대 100만 => 2차원 DP Table 을 설계할 수 있다.
dp[N][M] 은 어떤 값을 가져야하지? => LCS 를 구하는 문제이니까 인덱스 n, m 까지의 LCS 길이를 담고 있으면 된다.
관계식은 어떻게 도출하지? => dp[n][m] 을 갱신하기 위해서는 dp[n-1][m], dp[n][m-1], dp[n-1][m-1] 에 접근하면 된다.
"""